# Configuration and options dataclasses.

from __future__ import annotations

import sys
from dataclasses import field
from typing import TYPE_CHECKING, Annotated, Any, Literal

from mkdocstrings import get_logger

# YORE: EOL 3.10: Replace block with line 2.
if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self


_logger = get_logger(__name__)


try:
    # When Pydantic is available, use it to validate options (done automatically).
    # Users can therefore opt into validation by installing Pydantic in development/CI.
    # When building the docs to deploy them, Pydantic is not required anymore.

    # When building our own docs, Pydantic is always installed (see `docs` group in `pyproject.toml`)
    # to allow automatic generation of a JSON Schema. The JSON Schema is then referenced by mkdocstrings,
    # which is itself referenced by mkdocs-material's schema system. For example in VSCode:
    #
    # "yaml.schemas": {
    #     "https://squidfunk.github.io/mkdocs-material/schema.json": "mkdocs.yml"
    # }
    import pydantic

    if getattr(pydantic, "__version__", "1.").startswith("1."):
        raise ImportError  # noqa: TRY301

    # YORE: EOL 3.9: Remove block.
    if sys.version_info < (3, 10):
        try:
            import eval_type_backport  # noqa: F401
        except ImportError:
            _logger.debug(
                "Pydantic needs the `eval-type-backport` package to be installed "
                "for modern type syntax to work on Python 3.9. "
                "Deactivating Pydantic validation for Go handler options.",
            )
            raise

    from inspect import cleandoc

    from pydantic import Field as BaseField
    from pydantic.dataclasses import dataclass

    _base_url = "https://mkdocstrings.github.io/mkdocstrings-go/usage"

    def _Field(  # noqa: N802
        *args: Any,
        description: str,
        group: Literal["general"] | None = None,
        parent: str | None = None,
        **kwargs: Any,
    ) -> None:
        def _add_markdown_description(schema: dict[str, Any]) -> None:
            url = f"{_base_url}/{f'configuration/{group}/' if group else ''}#{parent or schema['title']}"
            schema["markdownDescription"] = f"[DOCUMENTATION]({url})\n\n{schema['description']}"

        return BaseField(
            *args,
            description=cleandoc(description),
            field_title_generator=lambda name, _: name,
            json_schema_extra=_add_markdown_description,
            **kwargs,
        )

except ImportError:
    from dataclasses import dataclass  # type: ignore[no-redef]
    # # two different dataclass classes, at no point are both used at the same time
    # ruff formatting breaks ignore comment

    def _Field(*args: Any, **kwargs: Any) -> None:  # type: ignore[misc]  # noqa: N802
        pass


if TYPE_CHECKING:
    from collections.abc import MutableMapping


# YORE: EOL 3.9: Remove block.
_dataclass_options = {"frozen": True}
if sys.version_info >= (3, 10):
    _dataclass_options["kw_only"] = True


# The input config class is useful to generate a JSON schema, see scripts/mkdocs_hooks.py.
# YORE: EOL 3.9: Replace `**_dataclass_options` with `frozen=True, kw_only=True` within line.
@dataclass(**_dataclass_options)  # type: ignore[call-overload]
class GoInputOptions:
    """Accepted input options."""

    extra: Annotated[
        dict[str, Any],
        _Field(
            group="general",
            description="Extra options.",
        ),
    ] = field(default_factory=dict)

    show_root_function: Annotated[
        bool,
        _Field(
            group="general",
            description="Show methods and functions if they are root of collected objects.",
        ),
    ] = True

    show_source: Annotated[
        bool,
        _Field(
            group="general",
            description="Show the source code of this object.",
        ),
    ] = True

    heading: Annotated[
        str,
        _Field(
            group="headings",
            description="A custom string to override the autogenerated heading of the root object.",
        ),
    ] = ""

    heading_level: Annotated[
        int,
        _Field(
            group="headings",
            description="The initial heading level to use.",
        ),
    ] = 2

    show_symbol_type_toc: Annotated[
        bool,
        _Field(
            group="headings",
            description="Show the symbol type in the Table of Contents (e.g. mod, class, methd, func and attr).",
        ),
    ] = False

    toc_label: Annotated[
        str,
        _Field(
            group="headings",
            description="A custom string to override the autogenerated toc label of the root object.",
        ),
    ] = ""

    show_root_full_path: Annotated[
        bool,
        _Field(
            group="docstrings",
            description="Show the full Go path for the root object heading.",
        ),
    ] = True

    show_object_full_path: Annotated[
        bool,
        _Field(
            group="docstrings",
            description="Show the full Go path of every object.",
        ),
    ] = False

    show_root_members_full_path: Annotated[
        bool,
        _Field(
            group="headings",
            description="Show the full Go path of the root members.",
        ),
    ] = False

    show_symbol_type_heading: Annotated[
        bool,
        _Field(
            group="headings",
            description="Show the symbol type in headings (e.g. func and struct).",
        ),
    ] = False

    show_root_heading: Annotated[
        bool,
        _Field(
            group="headings",
            description="""Show the heading of the object at the root of the documentation tree.

            The root object is the object referenced by the identifier after `:::`.
            """,
        ),
    ] = False

    line_length: Annotated[
        int,
        _Field(
            group="signatures",
            description="Maximum line length when formatting code/signatures.",
        ),
    ] = 60

    show_signature: Annotated[
        bool,
        _Field(
            group="signatures",
            description="Show methods and functions signatures.",
        ),
    ] = True

    @classmethod
    def coerce(cls, **data: Any) -> MutableMapping[str, Any]:
        """Coerce data."""
        return data

    @classmethod
    def from_data(cls, **data: Any) -> Self:
        """Create an instance from a dictionary."""
        return cls(**cls.coerce(**data))


@dataclass(**_dataclass_options)  # type: ignore[call-overload]
class GoOptions(GoInputOptions):  # type: ignore[override,unused-ignore]
    """Final options passed as template context."""

    # Re-declare any field to modify/narrow its type.

    @classmethod
    def coerce(cls, **data: Any) -> MutableMapping[str, Any]:
        """Create an instance from a dictionary."""
        # Coerce any field into its final form.
        return super().coerce(**data)


# The input config class is useful to generate a JSON schema, see scripts/mkdocs_hooks.py.
@dataclass(**_dataclass_options)  # type: ignore[call-overload]
class GoInputConfig:
    """Go handler configuration."""

    # We want to validate options early, so we load them as `GoInputOptions`.
    options: Annotated[
        GoInputOptions,
        _Field(
            description="Configuration options for collecting and rendering objects.",
        ),
    ] = field(default_factory=GoInputOptions)

    docstring_options: Annotated[
        None,
        _Field(
            group="docstrings",
            description="""The options for the docstring parser.

            See [docstring parsers](https://mkdocstrings.github.io/griffe/reference/docstrings/) and their options in Griffe docs.
            """,
        ),
    ] = None

    docstring_style: Annotated[
        None,
        _Field(
            group="docstrings",
            description="The docstring style to use: `auto`, `google`, `numpy`, `sphinx`, or `None`.",
        ),
    ] = None

    paths: Annotated[
        list[str],
        _Field(description="The paths in which to search for Go packages."),
    ] = field(default_factory=lambda: ["."])

    @classmethod
    def coerce(cls, **data: Any) -> MutableMapping[str, Any]:
        """Coerce data."""
        return data

    @classmethod
    def from_data(cls, **data: Any) -> Self:
        """Create an instance from a dictionary."""
        return cls(**cls.coerce(**data))


@dataclass(**_dataclass_options)  # type: ignore[call-overload]
class GoConfig(GoInputConfig):
    """Go handler configuration."""

    # We want to keep a simple dictionary in order to later merge global and local options.
    options: dict[str, Any] = field(default_factory=dict)  # type: ignore[assignment]
    """Global options in mkdocs.yml."""

    @classmethod
    def coerce(cls, **data: Any) -> MutableMapping[str, Any]:
        """Coerce data."""
        return super().coerce(**data)
